---
path: "/async-node-js"
date: "2020-05-26"
title: "짤막한 node.js의 비동기 이벤트 처리"
keywords : ["블로그", "개발자 블로그"]
---
`Node.js 디자인 패턴` 이라는 책을 구매했다. 책을 읽으면서 이해한 것들이나 조금더 리서치 한것들을 같이 적어보려고 한다.

Node.js 공식 페이지는 Node.js를 `an asynchronous event-driven JavaScript runtime` 이라고 표현했다.
이 문장을 보면 Node.js에 크게 2가지 특성이 있다는 걸 알 수 있다.
- 비동기 이벤트 주도
- JavaScript 런타임

비동기 이벤트 처리에 대한 니즈는 컴퓨터의 I/O 작업으로 부터 출발한다.

소프트웨어가 실행 될 때 I/O 작업은 지속적으로 일어나지만, 그 속도는 컴퓨터의 기본 동작중 가장 느리며 I/O가 진행되는 시간동안 지연을 동반하게 된다.
게다가 인간이라는 큰 외부 요인이 간섭하기 때문에 그 빈도는 늘어나며, 속도는 더욱 예측할 수 없게 되어버린다.

전통적으로 I/O작업은 블로킹 형태로 이루어졌다. 함수 호출이 작업이 완료될 때 까지 스레드의 실행이 차단된다.
그렇기 때문에 블로킹 I/O를 사용해 구현된 웹서버의 경우에 각 동시 연결에 대해서 다른 스레드나 프로세스를 사용했어야 했다.
이는 비교적 비용이 높고 비효율적인 방법이다.

최신 운영체제는 논블로킹 I/O 매커니즘을 지원한다. 이는 I/O 작업이 완료 될 때 까지 기다리지 않고 호출 즉시 제어를 반환하는 방법이다. 호출하는 순간에 결과를 사용할 수 없다면,
함수가 미리 정의된 상수를 반환하여 그 순간에 반환할 수 없는 데이터가 없음을 나타낸다.

이 논블로킹 리소스를 처리하는 방법은 여러가지가 있지만 `synchronous event demultiplexer`방식이 많이 사용되는데
일련의 I/O들이 처리할 수 있는 상태가 되기까지 다른 작업을 기다리는 효율적인 방식이다. 이 패턴을 사용하면 단일 스레드로도 여러 연결에 대응이 가능하다.
게다가 단일 스레드를 사용하면 각종 경합과 동기화에 대한 처리를 신경쓸 필요가 없다는 더 큰 이점이 존재한다.

Node.js는 비동기 작업을 Reactor패턴을 사용해 처리했다.
`event demultiplexer`와 `event queue` 두개의 계층을 두었다.

1. I/O가 일어나면 `event demultiplexer`에 등록하면서 즉시 논블로킹으로 제어를 반환하고
2. 이 I/O가 완료되면 `event queue`에 등록하여
3. 이벤트 루프가 각 이벤트에 해당하는 핸들러를 호출하는 방식이다.

I/O 작업은 사용자 레벨에서 직접 수행할 수 없어서 운영체제에서 제공하는 인터페이스를 사용해야 하는데, `event demultiplexer`도 마찬가지다.
epoll, kqueue, IOCP 같은 것들이 그 예시인데 각 운영체제나 리소스에 따라서 발생하는 불일치를 해결하기 위해 시스템 호출을 추상화하는 libuv를 만들었다.



